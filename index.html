<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Catch the Genie</title>
    <style>
        /* The font is still loaded via CSS for the canvas to use */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #0d021a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            /* Prevents double-tap zoom on mobile */
        }

        #game-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            box-shadow: 0 0 20px 5px rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: default;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // --- BROWSER COMPATIBILITY & SETUP ---
        window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');

        // --- THEME COLORS (used in canvas drawing) ---
        const THEME = {
            fontFamily: 'Cinzel, serif',
            bgColor: '#0d021a',
            textColor: '#f0e8d8',
            goldColor: '#ffd700',
            borderColor: '#a47c48',
            rubyColor: '#e0115f',
            emeraldColor: '#50c878',
            darkUI: 'rgba(10, 2, 20, 0.85)',
            lightGold: '#fff8e7',
        };

        // --- GAME CONFIGURATION CONSTANTS ---
        const GAME_DURATION = 60;
        const GOOD_GENIE_POINTS = 10;
        const EVIL_GENIE_POINTS = -15;
        const GOLDEN_GENIE_POINTS = 50;
        const GOLDEN_CHANCE = 0.08;
        const GOLDEN_GENIE_SCALE = 0.6;
        const INITIAL_SPAWN_INTERVAL = 650;
        const FINAL_SPAWN_INTERVAL = 200;
        const EVIL_CHANCE_START = 0.25;
        const EVIL_CHANCE_END = 0.40;
        const STREAK_TIMEOUT = 2000;
        const STREAK_BONUS_THRESHOLD = 5;
        const STREAK_BONUS_MULTIPLIER = 1.2;
        const MAX_PARTICLES = 200;

        // --- IMAGE LOADING ---
        const goodGenieImg = new Image();
        const evilGenieImg = new Image();
        const goldenGenieImg = new Image(); // New image for the golden genie
        let imagesLoaded = 0;
        const totalImages = 3;

        function onImageLoad() {
            imagesLoaded++;
        }

        goodGenieImg.onload = onImageLoad;
        evilGenieImg.onload = onImageLoad;
        goldenGenieImg.onload = onImageLoad;

        // Image data is embedded as Base64 to keep the game in a single file
        goodGenieImg.src = "W-genie.png";
        evilGenieImg.src = "L-genie.png";
        goldenGenieImg.src = "G-genie.png";

        // --- GAME STATE VARIABLES ---
        let gameState = 'menu';
        let score = 0;
        let bestScore = localStorage.getItem('genieCatcherBestScore') || 0;
        let timer = GAME_DURATION;
        let lastTime = 0;
        let spawnTimer = 0;
        let backgroundOffsetX = 0;

        // Gameplay Stats
        let goodGenieClicks = 0;
        let totalClicks = 0;
        let comboStreak = 0;
        let lastGoodClickTime = 0;
        let bonusActive = false;

        // Object pools
        let genie = [];
        let particles = [];
        let floatingTexts = [];
        let dunes = [];

        // UI and Input State
        let mousePos = { x: -1, y: -1, down: false };
        let uiElements = {};

        // Accessibility state
        let hintsEnabled = false;
        let colorAssistEnabled = false;
        let isMuted = false;

        // Audio Context (created on first user interaction)
        let audioCtx;

        // --- UTILITY FUNCTIONS ---
        const rand = (min, max) => Math.random() * (max - min) + min;
        const lerp = (a, b, t) => a + (b - a) * t;
        const isPointInRect = (point, rect) => (
            point.x > rect.x && point.x < rect.x + rect.w &&
            point.y > rect.y && point.y < rect.y + rect.h
        );

        // --- AUDIO SETUP ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!audioCtx || isMuted) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);

            switch (type) {
                case 'good': oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(600, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5); break;
                case 'evil': oscillator.type = 'square'; oscillator.frequency.setValueAtTime(120, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6); break;
                case 'bonus': oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4); oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.2); break;
                case 'click': oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2); break;
            }
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 1);
        }

        // --- GAME OBJECT FACTORIES ---
        function createGenie() {
            const progress = 1 - (timer / GAME_DURATION);
            const isEvil = Math.random() < lerp(EVIL_CHANCE_START, EVIL_CHANCE_END, progress);
            const isGolden = !isEvil && Math.random() < GOLDEN_CHANCE;
            const genieType = isGolden ? 'golden' : (isEvil ? 'evil' : 'good');

            let startPos, endPos, controlPos;
            const padding = 100; // Increased padding to ensure they start well off-screen
            const skyLimit = canvas.height * 0.75;

            const hCenterZone = canvas.width * 0.6;
            const hCenterStart = (canvas.width - hCenterZone) / 2;
            const vCenterZone = skyLimit * 0.7;
            const vCenterStart = (skyLimit - vCenterZone) / 2;

            const edge = Math.floor(rand(0, 4));
            switch (edge) {
                case 0: // Top to Bottom
                    startPos = { x: rand(0, canvas.width), y: -padding };
                    endPos = { x: rand(0, canvas.width), y: canvas.height + padding };
                    break;
                case 1: // Right to Left
                    startPos = { x: canvas.width + padding, y: rand(0, skyLimit) };
                    endPos = { x: -padding, y: rand(0, skyLimit) };
                    break;
                case 2: // Bottom to Top
                    startPos = { x: rand(0, canvas.width), y: canvas.height + padding };
                    endPos = { x: rand(0, canvas.width), y: -padding };
                    break;
                case 3: // Left to Right
                default:
                    startPos = { x: -padding, y: rand(0, skyLimit) };
                    endPos = { x: canvas.width + padding, y: rand(0, skyLimit) };
                    break;
            }

            controlPos = {
                x: rand(hCenterStart, hCenterStart + hCenterZone),
                y: rand(vCenterStart, vCenterStart + vCenterZone)
            };

            let speed = rand(0.0003, 0.0005);
            if (isGolden) speed *= 1.8;

            genie.push({
                id: Date.now() + Math.random(),
                startPos, controlPos, endPos,
                x: startPos.x, y: startPos.y,
                pathProgress: 0,
                speed,
                type: genieType,
                age: 0,
                visualAngle: rand(-0.2, 0.2),
                scale: 0.1, alpha: 0
            });
        }

        function createParticle(x, y, color, isGolden = false) {
            if (particles.length >= MAX_PARTICLES) return;
            const angle = rand(0, Math.PI * 2), speed = rand(1, 4);
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                lifespan: rand(isGolden ? 500 : 300, isGolden ? 1200 : 800),
                age: 0,
                radius: rand(isGolden ? 2 : 1, isGolden ? 5 : 4),
                color,
            });
        }

        function createFloatingText(text, x, y, color) {
            floatingTexts.push({ text, x, y, color, age: 0, lifespan: 1000 });
        }

        // --- RESIZE AND INPUT HANDLING ---
        function resizeCanvas() {
            const { width, height } = gameContainer.getBoundingClientRect();
            canvas.width = width;
            canvas.height = height;
            createDunes();
        }

        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY,
            };
        }

        function handlePointerMove(e) { mousePos = { ...getEventPos(e), down: mousePos.down }; }
        function handlePointerDown(e) {
            mousePos = { ...getEventPos(e), down: true };
            if (gameState === 'playing') handleGameClick(mousePos);
        }
        function handlePointerUp(e) {
            const clickPos = getEventPos(e);
            mousePos = { ...clickPos, down: false };
            if (gameState === 'menu' || gameState === 'gameover') {
                for (const key in uiElements) {
                    if (isPointInRect(clickPos, uiElements[key])) {
                        playSound('click');
                        uiElements[key].action();
                        return;
                    }
                }
            }
        }

        function handleGameClick(clickPos) {
            let clickedGenie = null;
            totalClicks++;
            for (let i = genie.length - 1; i >= 0; i--) {
                const j = genie[i];
                const isGolden = j.type === 'golden';

                const dynamicClickRadius = (canvas.width / 10) / 2;
                const clickRadius = dynamicClickRadius * (isGolden ? GOLDEN_GENIE_SCALE : 1);

                if (Math.hypot(clickPos.x - j.x, clickPos.y - j.y) < clickRadius * j.scale) {
                    clickedGenie = j;
                    break;
                }
            }

            if (clickedGenie) {
                let pointsAwarded = 0;
                if (clickedGenie.type === 'evil') {
                    score += EVIL_GENIE_POINTS;
                    createFloatingText(`${EVIL_GENIE_POINTS}`, clickedGenie.x, clickedGenie.y, THEME.rubyColor);
                    playSound('evil');
                    comboStreak = 0; bonusActive = false;
                } else {
                    goodGenieClicks++;
                    if (clickedGenie.type === 'golden') {
                        pointsAwarded = GOLDEN_GENIE_POINTS;
                        createFloatingText(`+${pointsAwarded}`, clickedGenie.x, clickedGenie.y, THEME.goldColor);
                    } else {
                        pointsAwarded = GOOD_GENIE_POINTS * (bonusActive ? STREAK_BONUS_MULTIPLIER : 1);
                        createFloatingText(`+${pointsAwarded.toFixed(0)}`, clickedGenie.x, clickedGenie.y, THEME.emeraldColor);
                    }
                    score += pointsAwarded;
                    playSound(clickedGenie.type === 'golden' ? 'bonus' : 'good');
                    const now = Date.now();
                    comboStreak = (now - lastGoodClickTime < STREAK_TIMEOUT) ? comboStreak + 1 : 1;
                    lastGoodClickTime = now;
                    bonusActive = false;
                    if (comboStreak > 0 && comboStreak % STREAK_BONUS_THRESHOLD === 0) {
                        bonusActive = true; playSound('bonus');
                        createFloatingText(`x${STREAK_BONUS_MULTIPLIER} BONUS!`, canvas.width / 2, 100, THEME.goldColor);
                    }
                }
                genie = genie.filter(j => j.id !== clickedGenie.id);
            } else {
                comboStreak = 0; bonusActive = false;
            }
        }

        // --- UPDATE LOGIC ---
        function update(dt) {
            if (gameState !== 'playing') {
                if (gameState === 'menu' || gameState === 'gameover') backgroundOffsetX += dt * 0.02;
                return;
            }

            backgroundOffsetX += dt * 0.05;
            timer -= dt / 1000;
            if (timer <= 0) { timer = 0; endGame(); return; }

            spawnTimer -= dt;
            if (spawnTimer <= 0) {
                createGenie();
                spawnTimer = lerp(INITIAL_SPAWN_INTERVAL, FINAL_SPAWN_INTERVAL, 1 - (timer / GAME_DURATION));
            }

            genie.forEach(j => {
                j.age += dt;
                j.visualAngle = Math.sin(j.age / 200) * 0.3;
                j.pathProgress += j.speed * dt;
                const t = j.pathProgress;
                const oneMinusT = 1 - t;
                j.x = oneMinusT * oneMinusT * j.startPos.x + 2 * oneMinusT * t * j.controlPos.x + t * t * j.endPos.x;
                j.y = oneMinusT * oneMinusT * j.startPos.y + 2 * oneMinusT * t * j.controlPos.y + t * t * j.endPos.y;

                if (j.age < 300) {
                    j.scale = lerp(0.1, 1, j.age / 300);
                    j.alpha = j.scale;
                } else {
                    j.scale = 1; j.alpha = 1;
                }

                if (Math.random() > 0.4) {
                    const isGolden = j.type === 'golden';
                    const color = isGolden ? '255, 215, 0' : (j.type === 'evil' ? '255, 100, 150' : '100, 200, 255');
                    createParticle(j.x, j.y, color, isGolden);
                }
            });

            particles.forEach(p => { p.age += dt; p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98; });
            floatingTexts.forEach(ft => ft.age += dt);

            genie = genie.filter(j => j.pathProgress < 1);
            particles = particles.filter(p => p.age < p.lifespan);
            floatingTexts = floatingTexts.filter(ft => ft.age < ft.lifespan);

            if (Date.now() - lastGoodClickTime > STREAK_TIMEOUT) { comboStreak = 0; bonusActive = false; }
        }


        // --- DRAWING LOGIC ---
        function drawDuneLayer(offsetX, baseHeight, color, amplitude, segmentWidth) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            const startX = -(offsetX % segmentWidth);
            let currentX = startX;
            ctx.lineTo(startX, baseHeight + Math.sin((startX + offsetX) / 200) * 5);
            while (currentX < canvas.width) {
                ctx.quadraticCurveTo(
                    currentX + segmentWidth / 2,
                    baseHeight - (amplitude + Math.sin((currentX + offsetX) / 150) * 10),
                    currentX + segmentWidth,
                    baseHeight + Math.sin((currentX + segmentWidth + offsetX) / 200) * 5
                );
                currentX += segmentWidth;
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
        }


        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a011a'); gradient.addColorStop(0.6, '#491a59'); gradient.addColorStop(1, '#d48a6A');
            ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 220, 0.6)';
            for (let i = 0; i < 100; i++) {
                ctx.beginPath();
                ctx.arc((i * 37) % canvas.width, (i * 101) % canvas.height, Math.sin(i) * 0.5 + 1, 0, Math.PI * 2);
                ctx.fill();
            }

            const moonX = canvas.width * 0.85; const moonY = canvas.height * 0.2; const moonRadius = 50;
            ctx.fillStyle = THEME.lightGold; ctx.beginPath(); ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#0a011a'; ctx.beginPath(); ctx.arc(moonX - moonRadius * 0.4, moonY - moonRadius * 0.2, moonRadius, 0, Math.PI * 2); ctx.fill();
            const glowGradient = ctx.createRadialGradient(moonX, moonY, moonRadius, moonX, moonY, moonRadius + 20);
            glowGradient.addColorStop(0, 'rgba(240, 232, 216, 0.4)'); glowGradient.addColorStop(1, 'rgba(240, 232, 216, 0)');
            ctx.fillStyle = glowGradient; ctx.beginPath(); ctx.arc(moonX, moonY, moonRadius + 20, 0, Math.PI * 2); ctx.fill();

            dunes.forEach(dune => drawDuneLayer(backgroundOffsetX * dune.parallaxFactor, dune.y, dune.color, dune.amplitude, dune.segmentWidth));
        }

        function drawGenie() {
            if (imagesLoaded < 2) return; // Wait for at least good/evil genie

            genie.forEach(j => {
                ctx.save();
                ctx.translate(j.x, j.y);

                const isGolden = j.type === 'golden';
                const scale = j.scale * (isGolden ? GOLDEN_GENIE_SCALE : 1);

                if (colorAssistEnabled) {
                    ctx.save();
                    ctx.scale(scale, scale);
                    const dynamicClickRadius = (canvas.width / 10) / 2;
                    ctx.strokeStyle = j.type === 'evil' ? 'rgba(255, 100, 100, 0.6)' : 'rgba(100, 200, 255, 0.6)';
                    ctx.lineWidth = 3 / scale;
                    ctx.beginPath(); ctx.arc(0, 0, dynamicClickRadius + 2, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }

                const offsetX = Math.sin(j.age / 200) * (isGolden ? 5 : 15);
                const offsetY = Math.cos(j.age / 250) * (isGolden ? 3 : 10);
                ctx.translate(offsetX, offsetY);

                ctx.scale(scale, scale);
                ctx.rotate(j.visualAngle);

                let imgToDraw = j.type === 'evil' ? evilGenieImg : goodGenieImg;
                let useGoldenFallback = isGolden && !(goldenGenieImg.complete && goldenGenieImg.naturalHeight !== 0);

                if (isGolden && !useGoldenFallback) {
                    imgToDraw = goldenGenieImg;
                }

                const baseSize = canvas.width / 10;
                const imgWidth = baseSize;
                const imgHeight = baseSize;

                ctx.globalAlpha = j.alpha;

                if (isGolden) {
                    const glowSize = imgWidth * 1.5;
                    const goldGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize / 2);
                    goldGlow.addColorStop(0, 'rgba(255, 235, 150, 0.7)');
                    goldGlow.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = goldGlow;
                    ctx.fillRect(-glowSize / 2, -glowSize / 2, glowSize, glowSize);
                }

                ctx.drawImage(imgToDraw, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);

                if (useGoldenFallback) {
                    ctx.globalCompositeOperation = 'source-atop';
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.fillRect(-imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
                }

                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                const life = p.age / p.lifespan;
                ctx.fillStyle = `rgba(${p.color}, ${1 - life})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius * (1 - life), 0, Math.PI * 2); ctx.fill();
            });
        }

        function drawFloatingTexts() {
            floatingTexts.forEach(ft => {
                const life = ft.age / ft.lifespan, alpha = 1 - Math.pow(life, 2);
                ctx.font = `bold 32px ${THEME.fontFamily}`;
                ctx.fillStyle = ft.color.startsWith('#') ? `${ft.color.slice(0, 7)}${Math.round(alpha * 255).toString(16).padStart(2, '0')}` : ft.color;
                ctx.strokeStyle = `rgba(0,0,0, ${alpha * 0.8})`; ctx.lineWidth = 4;
                ctx.strokeText(ft.text, ft.x, ft.y - (life * 40)); ctx.fillText(ft.text, ft.x, ft.y - (life * 40));
            });
        }

        function drawHUD() {
            ctx.save();
            ctx.textAlign = 'left'; ctx.font = `24px ${THEME.fontFamily}`;
            ctx.fillStyle = THEME.textColor; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;

            // --- MODIFIED LINES ---
            // Increased all Y-values to bring the HUD elements lower
            ctx.fillText(`Score: ${score}`, 20, 90);
            ctx.textAlign = 'center';
            ctx.fillText(`Best: ${bestScore}`, canvas.width / 2, 90);
            ctx.textAlign = 'right'; ctx.font = `bold 36px ${THEME.fontFamily}`;
            ctx.fillStyle = timer < 10 ? THEME.rubyColor : THEME.goldColor;
            ctx.fillText(`${Math.ceil(timer)}`, canvas.width - 30, 100);
            if (comboStreak > 1) {
                ctx.textAlign = 'center'; ctx.font = `bold 28px ${THEME.fontFamily}`;
                ctx.fillStyle = THEME.goldColor;
                ctx.fillText(`Streak: ${comboStreak}x`, canvas.width / 2, 130);
            }
            // --- END OF MODIFIED LINES ---

            ctx.restore();
        }

        // --- CANVAS UI DRAWING ---
        function drawText(text, x, y, size, color, align = 'center') {
            ctx.font = `${size}px ${THEME.fontFamily}`;
            ctx.fillStyle = color; ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }

        function wrapText(text, x, y, maxWidth, lineHeight, size, color) {
            ctx.font = `${size}px ${THEME.fontFamily}`;
            ctx.fillStyle = color; ctx.textAlign = 'center';
            let words = text.split(' '), line = '';
            for (let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ', metrics = ctx.measureText(testLine), testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    ctx.fillText(line, x, y); line = words[n] + ' '; y += lineHeight;
                } else { line = testLine; }
            }
            ctx.fillText(line, x, y);
        }

        function drawButton(element, text) {
            const isHover = isPointInRect(mousePos, element);
            const isDown = isHover && mousePos.down;
            ctx.save();
            const grad = ctx.createLinearGradient(element.x, element.y, element.x, element.y + element.h);
            grad.addColorStop(0, isDown ? THEME.borderColor : THEME.goldColor);
            grad.addColorStop(1, isDown ? THEME.goldColor : THEME.borderColor);
            ctx.fillStyle = grad; ctx.fillRect(element.x, element.y, element.w, element.h);
            ctx.strokeStyle = isHover ? THEME.lightGold : THEME.textColor;
            ctx.lineWidth = isHover ? 4 : 2;
            ctx.strokeRect(element.x, element.y, element.w, element.h);
            drawText(text, element.x + element.w / 2, element.y + element.h / 2 + 10, 24, THEME.bgColor);
            ctx.restore();
        }

        function drawToggle(element, text, enabled) {
            const isHover = isPointInRect(mousePos, element);
            ctx.save();
            drawText(text, element.x, element.y + 18, 20, isHover ? THEME.goldColor : THEME.textColor, 'left');
            const box = { x: element.x + element.w - 50, y: element.y, w: 50, h: 26 };
            ctx.fillStyle = enabled ? THEME.emeraldColor : '#333';
            ctx.roundRect(box.x, box.y, box.w, box.h, 13); ctx.fill();
            ctx.fillStyle = THEME.textColor;
            ctx.beginPath(); ctx.arc(box.x + (enabled ? box.w - 13 : 13), box.y + 13, 10, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }

        function defineMenuUI() {
            uiElements = {};
            const cx = canvas.width / 2, btnW = 250, btnH = 60;
            uiElements.playBtn = { x: cx - btnW / 2, y: canvas.height * 0.55, w: btnW, h: btnH, action: startGame };
            uiElements.hintsToggle = { x: cx - 200, y: canvas.height * 0.7, w: 400, h: 30, action: () => hintsEnabled = !hintsEnabled };
            uiElements.assistToggle = { x: cx - 200, y: canvas.height * 0.7 + 50, w: 400, h: 30, action: () => colorAssistEnabled = !colorAssistEnabled };
            uiElements.muteToggle = { x: cx - 200, y: canvas.height * 0.7 + 100, w: 400, h: 30, action: () => isMuted = !isMuted };
        }

        function drawMenu() {
            defineMenuUI();
            ctx.fillStyle = THEME.darkUI; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawText('Catch the Genie', canvas.width / 2, canvas.height * 0.2, 70, THEME.goldColor);
            wrapText('Click the good genie to score. Avoid the evil genie. Golden genie are worth more! You have 60 seconds.', canvas.width / 2, canvas.height * 0.35, 450, 30, 20, THEME.textColor);
            drawButton(uiElements.playBtn, 'Play');
            drawToggle(uiElements.hintsToggle, 'Hints (Stronger Colors)', hintsEnabled);
            drawToggle(uiElements.assistToggle, 'Color Assist (Outlines)', colorAssistEnabled);
            drawToggle(uiElements.muteToggle, 'Mute Audio', isMuted);
        }

        function defineGameOverUI() {
            uiElements = {};
            const cx = canvas.width / 2; const btnW = 250; const btnH = 60;
            uiElements.playAgainBtn = { x: cx - btnW / 2, y: canvas.height * 0.75, w: btnW, h: btnH, action: startGame };
        }

        function drawGameOver() {
            defineGameOverUI();
            ctx.fillStyle = THEME.darkUI; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawText('Time is Up!', canvas.width / 2, canvas.height * 0.2, 60, THEME.goldColor);
            const accuracy = totalClicks > 0 ? ((goodGenieClicks / totalClicks) * 100).toFixed(1) : 0;
            drawText(`Final Score: ${score}`, canvas.width / 2, canvas.height * 0.35, 30, THEME.textColor);
            drawText(`Best Score: ${bestScore}`, canvas.width / 2, canvas.height * 0.45, 30, THEME.textColor);
            drawText(`Genie Caught: ${goodGenieClicks}`, canvas.width / 2, canvas.height * 0.55, 30, THEME.textColor);
            drawText(`Accuracy: ${accuracy}%`, canvas.width / 2, canvas.height * 0.65, 30, THEME.textColor);
            drawButton(uiElements.playAgainBtn, 'Play Again');
        }

        // --- GAME STATE MANAGEMENT ---
        function startGame() {
            initAudio();
            gameState = 'playing'; score = 0; timer = GAME_DURATION;
            genie = []; particles = []; floatingTexts = [];
            spawnTimer = 500; goodGenieClicks = 0; totalClicks = 0;
            comboStreak = 0; lastGoodClickTime = 0; backgroundOffsetX = 0;
        }

        function endGame() {
            gameState = 'gameover';
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('genieCatcherBestScore', bestScore);
            }
        }

        // --- MAIN GAME LOOP ---
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const dt = timestamp - lastTime;
            lastTime = timestamp;

            update(dt);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            if (gameState === 'playing' || gameState === 'gameover') {
                drawParticles();
                drawGenie();
                drawFloatingTexts();
            }

            if (gameState === 'playing') {
                drawHUD();
            } else if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'gameover') {
                drawGameOver();
            }

            requestAnimationFrame(gameLoop);
        }

        // --- INITIALIZATION ---
        function createDunes() {
            dunes = [
                { y: canvas.height * 0.75 + 10, parallaxFactor: 0.2, color: '#21082e', amplitude: 20, segmentWidth: 500 },
                { y: canvas.height * 0.85, parallaxFactor: 0.5, color: '#311242', amplitude: 30, segmentWidth: 400 },
                { y: canvas.height * 0.95, parallaxFactor: 1.0, color: '#451b5c', amplitude: 40, segmentWidth: 300 },
            ];
        }

        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handlePointerMove(e); }, { passive: false });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handlePointerDown(e); }, { passive: false });
        canvas.addEventListener('touchend', e => { e.preventDefault(); handlePointerUp(e); }, { passive: false });

        if (!ctx.roundRect) {
            // Polyfill for roundRect if not supported
            ctx.roundRect = function (x, y, w, h, r) {
                this.beginPath(); this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r); this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r); this.arcTo(x, y, x + w, y, r); this.closePath();
            }
        }

        resizeCanvas();
        requestAnimationFrame(gameLoop);

    </script>
</body>

</html>
